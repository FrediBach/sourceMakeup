<table class="container" cellpadding="0" cellspacing="0"><thead><th class="comment"><select id="files"><option selected>sourcemakeup.php</option><option>js/jquery.jkit.1.1.28.js</option><option>js/sourcemakeup.js</option><option>css/sourcemakeup.css</option></select>Documentation</th><th class="code">Code</th></thead><tbody><tr class="docu"><td class="comment"><h1 id="sourcemakeup">sourceMakeup</h1>

<p>sourceMakeup is a source code viewer written in PHP on the backend, and jQuery and jKit
on the frontend. sourceMakeup was heavely inspired by the first versions of
<a href="http://jashkenas.github.com/docco/">Docco</a>, with some additional features that enhance
the frontend visually and feature wise. It was mainly developed as a source code viewer
for the jQuery based UI toolkit <a href="http://jquery-jkit.com/">jKit</a>. It's main use is to
create beautiful source documentation for JavaScript libraries and plugins, but it can
be used to document small PHP code and CSS markup as well, however, with some limitations.</p>

<p>Comments for sourceMakeup should be written in Markdown. This way sourceMakeup can correctly
and beautifully format the code and add a navigation menu linked to the different parts of your code.</p>

<ul>
<li>Version: <code>0.5</code></li>
<li>Release date: <code>14. 3. 2013</code></li>
<li><a href="http://jquery-jkit.com/sourcemakeup/">Documentation &amp; Demos</a></li>
<li><a href="https://github.com/FrediBach/sourceMakeup/archive/master.zip">Download</a></li>
</ul>

<h2 id="copyright">Copyright</h2>

<ul>
<li>(c) 2013 by <em>Fredi Bach</em></li>
<li><a href="http://fredibach.ch/">Home</a></li>
</ul>

<h2 id="license">License</h2>

<p>sourceMakeup is open source and MIT licensed. For more informations read the <strong>license.txt</strong> file</p>
</td><td class="code"><pre class="linenumbers"></pre><pre class="prettyprint"></pre></td></tr><tr class="docu"><td class="comment"><h2 id="settings">Settings</h2>
</td><td class="code"><pre class="linenumbers"></pre><pre class="prettyprint"></pre></td></tr><tr class="docu"><td class="comment"><ul>
<li><strong>$dir</strong> contains the path to the documented files</li>
<li><strong>$file</strong> is the main file</li>
<li><strong>$files</strong> contains all the files, leave it empty if you don't want to restrict the list to certain files</li>
<li><strong>$extensions</strong> contains a comma separated list of allowed file extensions</li>
<li><strong>$filter</strong> filters out any files that contain a certain string</li>
<li><strong>$dev</strong> mode ignores the cache file and always generates a new one</li>
</ul>
</td><td class="code"><pre class="linenumbers">39
40
41
42
43
44
45
46
47
48
49</pre><pre class="prettyprint">    $dir = './';
    $file = 'sourcemakeup.php';
    $files = array(
                'sourcemakeup.php',
                'js/jquery.jkit.1.1.28.js',
                'js/sourcemakeup.js',
                'css/sourcemakeup.css'
    );
    $extensions = 'js,php,css';
    $filter = '.min.js';
    $dev = true;</pre></td></tr><tr class="docu"><td class="comment"><h2 id="the-source">The Source</h2>
</td><td class="code"><pre class="linenumbers"></pre><pre class="prettyprint"></pre></td></tr><tr class="docu"><td class="comment"><p>Is the main file the one from the settings or another one?</p>
</td><td class="code"><pre class="linenumbers">55
56
57</pre><pre class="prettyprint">    if (isset($_GET['file']) &amp;&amp; $_GET['file'] != ''){
        $file = $_GET['file'];
    }</pre></td></tr><tr class="docu"><td class="comment"><p>Define the path for our cached file:</p>
</td><td class="code"><pre class="linenumbers">61</pre><pre class="prettyprint">    $cachefile = 'cache/'.md5($file).'.txt';</pre></td></tr><tr class="docu"><td class="comment"><p>Create a list of all files we want to document. In case <strong>$files</strong> is not empty, those files will be used and
the following code block will be ignored.</p>
</td><td class="code"><pre class="linenumbers">66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82</pre><pre class="prettyprint">    if (count($files) == 0){
        if ($dir != ''){
            $tempfiles = scandir($dir);
            $files = array();
            foreach($tempfiles as $f){
                if ($f != '.' &amp;&amp; $f != '..' &amp;&amp; stripos($f, $filter) === false){
                    $allowed = explode(',', $extensions);
                    $ext = pathinfo($f, PATHINFO_EXTENSION);
                    if (in_array($ext, $allowed)) {
                        $files[] = $f;
                    }
                }
            }
        } else {
            $files = array($file);
        }
    }</pre></td></tr><tr class="docu"><td class="comment"><p>Do we have to load the cahed file or create a new one?</p>
</td><td class="code"><pre class="linenumbers">86</pre><pre class="prettyprint">    if (file_exists($cachefile) &amp;&amp; !$dev){</pre></td></tr><tr class="docu"><td class="comment"><p>Load the cached file:</p>
</td><td class="code"><pre class="linenumbers">90
91
92</pre><pre class="prettyprint">        $output = file_get_contents($cachefile);
    
    } else {</pre></td></tr><tr class="docu"><td class="comment"><p>Ok, so we need to create new output. To do that we first need to include the Markdown class:</p>
</td><td class="code"><pre class="linenumbers">96</pre><pre class="prettyprint">        include_once &quot;libs/markdown/markdown.php&quot;;</pre></td></tr><tr class="docu"><td class="comment"><p>Load the file and create an array of all lines:</p>
</td><td class="code"><pre class="linenumbers">100
101</pre><pre class="prettyprint">        $data = file_get_contents($file);
        $lines = explode(&quot;\n&quot;, $data);</pre></td></tr><tr class="docu"><td class="comment"><p>Create some variables we need later:</p>
</td><td class="code"><pre class="linenumbers">105
106
107
108</pre><pre class="prettyprint">        $blocks = array();
        $iscomment = false;
        $currentblock = 0;
        $linenumber = 0;</pre></td></tr><tr class="docu"><td class="comment"><p>Step through all lines and combine them into codeblocks. Each codeblock can have following contents:</p>

<ul>
<li><strong>comment</strong> contains all comments of this codeblock</li>
<li><strong>code</strong> contains all code of this block</li>
<li><strong>lnr</strong> contains the original linenumbers for the above code</li>
</ul>
</td><td class="code"><pre class="linenumbers">116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137</pre><pre class="prettyprint">        foreach($lines as $line){
        
            $linenumber++;
        
            if (substr(trim($line),0,2) == '//'){
                if (!$iscomment){
                    $currentblock++;
                }
                $blocks[$currentblock]['comment'] .= &quot;\n&quot;.substr(trim($line),3);
                $blocks[$currentblock]['code'] .= &quot;&quot;;
                $iscomment = true;
                if (substr(trim(substr(trim($line),3)),0,3) == '{!}'){
                    $currentblock++;
                }
            } else {
                $blocks[$currentblock]['code'] .= &quot;\n&quot;.str_replace(&quot;\t&quot;, &quot;    &quot;, $line);
                $blocks[$currentblock]['lnr'] .= &quot;\n&quot;.$linenumber;
                $blocks[$currentblock]['comment'] .= &quot;&quot;;
                $iscomment = false;
            }
    
        }</pre></td></tr><tr class="docu"><td class="comment"><p>If this is a PHP script with <strong>&lt;?php</strong> on the first line, we're going to remove it as it's only ruining our design:</p>
</td><td class="code"><pre class="linenumbers">141
142
143</pre><pre class="prettyprint">        if (trim($blocks[0]['code']) == '&lt;?php'){
            $blocks[0]['code'] = '';
        }</pre></td></tr><tr class="docu"><td class="comment"><p>We have now all we need to construct the table that contains all of our code. The table
has two columns, the first contains all the comments and the second one contains all the code.</p>
</td><td class="code"><pre class="linenumbers">148</pre><pre class="prettyprint">        $output = '';</pre></td></tr><tr class="docu"><td class="comment"><p>First contruct the table header:</p>
</td><td class="code"><pre class="linenumbers">152
153
154
155
156
157
158
159
160
161
162</pre><pre class="prettyprint">        $output .= '&lt;table class=&quot;container&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;';
        $output .= '&lt;thead&gt;&lt;th class=&quot;comment&quot;&gt;&lt;select id=&quot;files&quot;&gt;';
        foreach($files as $f){
            if ($f == $file){
                $output .= '&lt;option selected&gt;'.$f.'&lt;/option&gt;';
            } else {
                $output .= '&lt;option&gt;'.$f.'&lt;/option&gt;';
            }
        }
        $output .= '&lt;/select&gt;Documentation&lt;/th&gt;&lt;th class=&quot;code&quot;&gt;Code&lt;/th&gt;';
        $output .= '&lt;/thead&gt;&lt;tbody&gt;';</pre></td></tr><tr class="docu"><td class="comment"><p>Loop through all blocks and construct the rows of our table:</p>
</td><td class="code"><pre class="linenumbers">166</pre><pre class="prettyprint">        foreach($blocks as $block){</pre></td></tr><tr class="docu"><td class="comment"><p>Each block is a row with a comment and a code column. Sometimes only one of them actually has content and
if both have no content, simply skip this block.</p>
</td><td class="code"><pre class="linenumbers">171
172
173
174
175</pre><pre class="prettyprint">            if (trim($block['comment']) != '' || trim($block['code']) != ''){
                
                $output .= '&lt;tr class=&quot;docu&quot;&gt;';
                
                if (substr(trim($block['comment']),0,3) == '{!}'){</pre></td></tr><tr class="docu"><td class="comment"><p>This block is an instruction block. Instruction blocks can be created like this:</p>

<pre><code>{!} instructiontype: instruction
</code></pre>
</td><td class="code"><pre class="linenumbers"></pre><pre class="prettyprint"></pre></td></tr><tr class="docu"><td class="comment"><p>Instructions are normally hidden, but can be made visible. They are ment to contain special
instructions either for a script or for code contributors. If you use them, make sure to supply the
icons for each of your instruction type. They have to ba named like this:</p>

<pre><code>sourcemakeup.instructiontype.png
</code></pre>
</td><td class="code"><pre class="linenumbers">188
189
190
191
192
193
194
195
196
197</pre><pre class="prettyprint">                    $split = explode(':', substr(trim($block['comment']),3));
                    
                    $block['comment'] = '&lt;span class=&quot;itype&quot;&gt;';
                    $block['comment'] .= '&lt;img src=&quot;imgs/sourcemakeup.'.trim($split[0]).'.png&quot;&gt; '.$split[0].'&lt;/span&gt;';
                    $block['comment'] .= ':&lt;span class=&quot;iopt&quot;&gt;'.$split[1].'&lt;/span&gt;';
                    
                    $output .= '&lt;td class=&quot;comment instruction&quot;&gt;&amp;nbsp;&lt;/td&gt;';
                    $output .= '&lt;td class=&quot;code instruction&quot;&gt;'.$block['comment'].'&lt;/td&gt;';
                    
                } else {</pre></td></tr><tr class="docu"><td class="comment"><p>This is a regular codeblock. As we don't want to display any uneeded linebreaks, we
use a special funtion to strip them away. The function returns an array that not only
contains the stripped code, it tells us exactly how many lines where removed from the
beginning and from the end. This way we can strip exactly the same number of lines from
the linenumber string.</p>
</td><td class="code"><pre class="linenumbers">205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221</pre><pre class="prettyprint">                    $codedata = trimLinebreaks($block['code']);
                
                    $templines = explode(&quot;\n&quot;, $block['lnr']);
                
                    if ($codedata['shifted'] &gt; 0){
                        for ($i=1; $i&lt;=$codedata['shifted']; $i++){
                            array_shift($templines);
                        }
                    }
                
                    if ($codedata['popped'] &gt; 0){
                        for ($i=1; $i&lt;=$codedata['popped']; $i++){
                            array_pop($templines);
                        }
                    }
                
                    $lnr = implode(&quot;\n&quot;, $templines);</pre></td></tr><tr class="docu"><td class="comment"><p>For the comment column, we basically do two things. We parse the Markdown formatting into nice HTML
with the Markdown library, and we than add ids to all HTML headers so that we can create an anchor navigation.</p>
</td><td class="code"><pre class="linenumbers">226</pre><pre class="prettyprint">                    $output .= '&lt;td class=&quot;comment&quot;&gt;'.addHeaderAnchors(Markdown(trim($block['comment']))).'&lt;/td&gt;';</pre></td></tr><tr class="docu"><td class="comment"><p>All we need to do for the code is escape the HTML special chars. The formatting is done by the Google Code Prettifier JavaScript.</p>
</td><td class="code"><pre class="linenumbers">230
231
232
233
234
235
236
237
238
239</pre><pre class="prettyprint">                    $output .= '&lt;td class=&quot;code&quot;&gt;&lt;pre class=&quot;linenumbers&quot;&gt;'.$lnr.'&lt;/pre&gt;';
                    $output .= '&lt;pre class=&quot;prettyprint&quot;&gt;'.htmlspecialchars($codedata['code']).'&lt;/pre&gt;&lt;/td&gt;';
                }
                
                $output .= '&lt;/tr&gt;';
                
            }
        }
    
        $output .= '&lt;/tbody&gt;&lt;/table&gt;';</pre></td></tr><tr class="docu"><td class="comment"><p>Now as we created our output, we save it in a cache for later use:</p>
</td><td class="code"><pre class="linenumbers">243
244
245
246
247</pre><pre class="prettyprint">        $fh = fopen($cachefile, 'w') or die(&quot;can't open file&quot;);
        fwrite($fh, $output);
        fclose($fh);
    
    }</pre></td></tr><tr class="docu"><td class="comment"><p>And lastly, we inlude the template to generate our output:</p>
</td><td class="code"><pre class="linenumbers">251</pre><pre class="prettyprint">    include 'sourcemakeup.template.php';</pre></td></tr><tr class="docu"><td class="comment"><h2 id="functions">Functions</h2>
</td><td class="code"><pre class="linenumbers"></pre><pre class="prettyprint"></pre></td></tr><tr class="docu"><td class="comment"><p>The <strong>addHeaderAnchors</strong> function and the regex callback function <strong>addHeaderAnchorsCallback</strong>
add ids to each header in the supplied HTML based on the title of the header.</p>
</td><td class="code"><pre class="linenumbers">259
260
261
262
263
264
265</pre><pre class="prettyprint">    function addHeaderAnchors($text){
        return preg_replace_callback('/\&lt;h([0-6]{1})\&gt;(.+)\&lt;\/h[0-6]{1}\&gt;/', 'addHeaderAnchorsCallback', $text);
    }
    
    function addHeaderAnchorsCallback($matches){
        return '&lt;h'.$matches[1].' id=&quot;'.createURLSlug($matches[2]).'&quot;&gt;'.$matches[2].'&lt;/h'.$matches[1].'&gt;';
    }</pre></td></tr><tr class="docu"><td class="comment"><p>The <strong>createURLSlug</strong> function makes a nice url slug where all special characters are removed and spaces replaced with
the "-" character.</p>
</td><td class="code"><pre class="linenumbers">270
271
272
273
274
275
276
277
278
279
280
281</pre><pre class="prettyprint">    function createURLSlug($str, $replace=array(), $delimiter='-'){
        if( !empty($replace) ) {
            $str = str_replace((array)$replace, ' ', $str);
        }

        $clean = iconv('UTF-8', 'ASCII//TRANSLIT', $str);
        $clean = preg_replace(&quot;/[^a-zA-Z0-9\/_|+ -]/&quot;, '', $clean);
        $clean = strtolower(trim($clean, '-'));
        $clean = preg_replace(&quot;/[\/_|+ -]+/&quot;, $delimiter, $clean);

        return $clean;
    }</pre></td></tr><tr class="docu"><td class="comment"><p>The <strong>trimLinebreaks</strong> function removes all unneaded linebreaks before an after a string and tells
us in the return array exactly how many of them.</p>
</td><td class="code"><pre class="linenumbers">286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307</pre><pre class="prettyprint">    function trimLinebreaks($string){
    
        $lines = explode(&quot;\n&quot;, $string);
    
        $shifted = 0;
        $popped = 0;
    
        while(trim($lines[0]) == '' &amp;&amp; count($lines) &gt; 0){
            array_shift($lines);
            $shifted++;
        }
    
        while( trim( $lines[count($lines)-1] ) == '' &amp;&amp; count($lines) &gt; 0){
            array_pop($lines);
            $popped++;
        }
    
        $arr = array('code' =&gt; implode(&quot;\n&quot;, $lines), 'shifted' =&gt; $shifted, 'popped' =&gt; $popped);
    
        return $arr;
    
    }</pre></td></tr></tbody></table>